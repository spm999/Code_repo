// controllers/codeController.js
const CodeFile = require("../models/CodeFile");
const CodeVersion = require("../models/CodeVersion");
const User = require("../models/User");
const { cloudinary } = require("../utils/cloudinary");
const { sendEmail, emailTemplates } = require("../utils/emailService");

const asyncHandler = fn => (req, res) => fn(req, res).catch(err => {
  console.error(err);
  res.status(500).json({ success: false, message: err.message || "Server error" });
});

// Helper function to assign reviewer automatically
const assignReviewer = async (codeFile) => {
  try {
    const reviewers = await User.find({ 
      role: 'reviewer',
      isActive: true 
    });
    
    if (reviewers.length === 0) {
      console.log('No reviewers available');
      return null;
    }
    
    const randomReviewer = reviewers[Math.floor(Math.random() * reviewers.length)];
    
    codeFile.assignedReviewer = randomReviewer._id;
    codeFile.approvalStatus = 'pending_reviewer';
    await codeFile.save();
    
    // Send email notification to reviewer
    const author = await User.findById(codeFile.createdBy);
    if (randomReviewer.email && author) {
      const emailContent = emailTemplates.reviewerAssignment(
        codeFile, 
        randomReviewer, 
        author
      );
      await sendEmail(randomReviewer.email, emailContent.subject, emailContent.html);
    }
    
    return randomReviewer;
  } catch (error) {
    console.error('Error assigning reviewer:', error);
    return null;
  }
};

// Helper function to check file access
const checkFileAccess = (codeFile, userId, isAdmin = false) => {
  if (isAdmin) return true;
  if (codeFile.createdBy.toString() === userId.toString()) return true;
  return codeFile.collaborators.some(collab => collab.user.toString() === userId.toString());
};

// Helper function to check edit permissions
const checkEditPermission = (codeFile, userId, isAdmin = false) => {
  if (isAdmin) return true;
  if (codeFile.createdBy.toString() === userId.toString()) return true;
  return codeFile.collaborators.some(collab => 
    collab.user.toString() === userId.toString() && 
    collab.permission === "suggest_edits"
  );
};




// GET all files
exports.getCodeFiles = async (req, res) => {
  try {
    const files = await CodeFile.find().sort({ createdAt: -1 });

    if (!files.length) {
      console.warn("âš ï¸ No files found in DB.");
      return res.status(404).json({ message: "No files found" });
    }

    console.log(`ðŸ“‚ Retrieved ${files.length} files from DB.`);
    files.forEach((file, idx) => {
      console.log(`\n#${idx + 1}`);
      console.log("ðŸ”— URL:", file.url);
      console.log("ðŸ†” Public ID:", file.public_id);
      console.log("ðŸ“„ Name:", file.filename);
    });

    res.json(files);
  } catch (err) {
    console.error("âŒ Error fetching files:", err.message);
    res.status(500).json({ error: "Server error" });
  }
};

// GET single file by ID
exports.getCodeFile = async (req, res) => {
  try {
    const file = await CodeFile.findById(req.params.id);

    if (!file) {
      console.warn(`âš ï¸ File not found with ID: ${req.params.id}`);
      return res.status(404).json({ message: "File not found" });
    }

    console.log("âœ… File retrieved from DB:");
    console.log("ðŸ”— URL:", file.url);
    console.log("ðŸ†” Public ID:", file.public_id);
    console.log("ðŸ“„ Name:", file.filename);

    res.json(file);
  } catch (err) {
    console.error(`âŒ Error fetching file with ID ${req.params.id}:`, err.message);
    res.status(500).json({ error: "Server error" });
  }
};





// @desc Create a new code file
// @route POST /api/code/files
exports.createCodeFile = async (req, res) => {
  try {
    const { title, description, language, tags, isPublic } = req.body;

    // Validate required fields
    if (!title || !language) {
      return res.status(400).json({
        success: false,
        message: "Title and language are required"
      });
    }

    // Create new code file
    const codeFile = await CodeFile.create({
      title,
      description: description || '',
      language,
      tags: tags ? tags.split(',').map(tag => tag.trim()) : [],
      createdBy: req.user.id,
      isPublic: isPublic === 'true',
      approvalStatus: 'draft'
    });

    // Populate the createdBy field for response
    await codeFile.populate('createdBy', 'username email');

    // Auto-assign reviewer
    const reviewer = await assignReviewer(codeFile);

    res.status(201).json({
      success: true,
      message: "Code file created successfully",
      data: codeFile,
      assignedReviewer: reviewer
    });

  } catch (err) {
    console.error('Create code file error:', err);
    
    if (err.name === 'ValidationError') {
      const errors = Object.values(err.errors).map(error => error.message);
      return res.status(400).json({
        success: false,
        message: "Validation error",
        errors: errors
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Upload code file version to Cloudinary and save to database
// @route POST /api/code/files/:id/upload
exports.uploadCodeVersion = async (req, res) => {
  try {
    console.log('Upload request received:', req);
    
    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded or invalid file type"
      });
    }

    // Find the code file
    const codeFile = await CodeFile.findById(req.params.id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check permissions
    if (!checkEditPermission(codeFile, req.user.id, req.user.role === 'admin')) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to upload to this file"
      });
    }

    // Get Cloudinary upload result
    const cloudinaryResult = req.file;

    // Determine version number
    const existingVersions = await CodeVersion.find({ codeFile: req.params.id });
    const versionNumber = existingVersions.length + 1;

console.log("HI1")

    // Create new code version
    const codeVersion = await CodeVersion.create({
      codeFile: req.params.id,
      version: `v${versionNumber}.0`,
      fileUrl: cloudinaryResult.path,
      fileName: req.file.originalname,
      fileSize: req.file.size,
      cloudinaryPublicId: cloudinaryResult.filename,
      author: req.user.id,
      status: 'draft',
      isActive: false,
      mimeType: req.file.mimetype
    });

console.log(codeVersion, "created codeversion")

    console.log('CodeVersion created:', codeVersion._id);

    // If user owns the file, set as current version and update workflow
    if (codeFile.createdBy.toString() === req.user.id.toString()) {
      codeFile.currentVersion = codeVersion._id;
      
      // Reset approval workflow
      codeFile.approvalStatus = 'draft';
      
      // Reassign reviewer if needed
      if (!codeFile.assignedReviewer) {
        await assignReviewer(codeFile);
      } else {
        codeFile.approvalStatus = 'pending_reviewer';
      }
      
      codeFile.lastUpdatedBy = req.user.id;
      codeFile.lastUpdatedAt = new Date();
      await codeFile.save();
      
      console.log('CodeFile updated with new version');
    }

    // Populate author info for response
    await codeVersion.populate('author', 'username email');

    res.status(201).json({
      success: true,
      message: "File uploaded successfully to Cloudinary",
      data: codeVersion,
      cloudinaryInfo: {
        publicId: cloudinaryResult.filename,
        url: cloudinaryResult.path,
        format: cloudinaryResult.format,
        bytes: cloudinaryResult.size
      }
    });

  } catch (err) {
    console.error('Upload error:', err);
    
    // Clean up uploaded file from Cloudinary if error occurred after upload
    if (req.file && req.file.filename) {
      try {
        await cloudinary.uploader.destroy(req.file.filename);
        console.log('Cleaned up Cloudinary file due to error:', req.file.filename);
      } catch (cleanupError) {
        console.error('Error cleaning up Cloudinary file:', cleanupError);
      }
    }
    
    if (err.name === 'ValidationError') {
      const errors = Object.values(err.errors).map(error => error.message);
      return res.status(400).json({
        success: false,
        message: "Validation error",
        errors: errors
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: "File upload failed: " + err.message 
    });
  }
};





// controllers/codeController.js (additional functions)

// @desc Update code file metadata
// @route PUT /api/code/files/:id
exports.updateCodeFile = async (req, res) => {
  try {
    const { title, description, language, tags, isPublic, notifications } = req.body;

    const codeFile = await CodeFile.findById(req.params.id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user owns the file or is admin/collaborator with edit permission
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin' &&
        !codeFile.collaborators.some(collab => 
          collab.user.toString() === req.user.id.toString() && 
          collab.permission === "suggest_edits"
        )) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to update this file"
      });
    }

    // Prepare update data
    const updateData = {
      title: title || codeFile.title,
      description: description || codeFile.description,
      language: language || codeFile.language,
      lastUpdatedBy: req.user.id,
      lastUpdatedAt: new Date()
    };

    // Handle tags if provided
    if (tags !== undefined) {
      updateData.tags = tags ? tags.split(',').map(tag => tag.trim()) : [];
    }

    // Handle isPublic if provided
    if (isPublic !== undefined) {
      updateData.isPublic = isPublic === 'true';
    }

    // Handle notifications if provided
    if (notifications) {
      updateData.notifications = {
        ...codeFile.notifications,
        ...notifications
      };
    }

    const updatedFile = await CodeFile.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true, runValidators: true }
    )
    .populate('createdBy', 'username email')
    .populate('currentVersion')
    .populate('assignedReviewer', 'username email')
    .populate('assignedAdmin', 'username email')
    .populate('collaborators.user', 'username email');

    res.json({
      success: true,
      message: "Code file updated successfully",
      data: updatedFile
    });
  } catch (err) {
    console.error('Update code file error:', err);
    
    if (err.name === 'ValidationError') {
      const errors = Object.values(err.errors).map(error => error.message);
      return res.status(400).json({
        success: false,
        message: "Validation error",
        errors: errors
      });
    }
    
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Add collaborator to code file
// @route POST /api/code/files/:id/collaborators
exports.addCollaborator = async (req, res) => {
  try {
    const { email, permission = "view" } = req.body;

    // Validate input
    if (!email) {
      return res.status(400).json({
        success: false,
        message: "Email is required"
      });
    }

    if (!["view", "suggest_edits"].includes(permission)) {
      return res.status(400).json({
        success: false,
        message: "Invalid permission type. Use 'view' or 'suggest_edits'"
      });
    }

    const codeFile = await CodeFile.findById(req.params.id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user owns the file or is admin
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to add collaborators"
      });
    }

    // Check if file is approved (optional requirement)
    if (codeFile.approvalStatus !== 'approved') {
      return res.status(400).json({
        success: false,
        message: "Only approved files can have collaborators"
      });
    }

    // Find user by email
    const userToAdd = await User.findOne({ email: email.toLowerCase() });
    if (!userToAdd) {
      return res.status(404).json({
        success: false,
        message: "User not found with this email"
      });
    }

    // Check if user is trying to add themselves
    if (userToAdd._id.toString() === req.user.id.toString()) {
      return res.status(400).json({
        success: false,
        message: "Cannot add yourself as a collaborator"
      });
    }

    // Check if user is already a collaborator
    const existingCollaborator = codeFile.collaborators.find(
      collab => collab.user.toString() === userToAdd._id.toString()
    );

    if (existingCollaborator) {
      return res.status(400).json({
        success: false,
        message: "User is already a collaborator"
      });
    }

    // Check if user is the file owner
    if (codeFile.createdBy.toString() === userToAdd._id.toString()) {
      return res.status(400).json({
        success: false,
        message: "User is the owner of this file"
      });
    }

    // Add collaborator
    codeFile.collaborators.push({
      user: userToAdd._id,
      permission: permission,
      addedBy: req.user.id,
      addedAt: new Date()
    });

    await codeFile.save();

    // Populate for response
    const updatedFile = await CodeFile.findById(req.params.id)
      .populate('collaborators.user', 'username email')
      .populate('createdBy', 'username email');

    // Send email notification to collaborator
    if (userToAdd.email) {
      try {
        const emailContent = emailTemplates.fileShared(
          codeFile,
          userToAdd,
          req.user,
          permission
        );
        await sendEmail(userToAdd.email, emailContent.subject, emailContent.html);
      } catch (emailError) {
        console.error('Email sending failed:', emailError);
        // Continue even if email fails
      }
    }

    res.json({
      success: true,
      message: `Collaborator ${userToAdd.username} added successfully`,
      data: updatedFile
    });
  } catch (err) {
    console.error('Add collaborator error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Share code file via email with non-users
// @route POST /api/code/files/:id/share
exports.shareCodeFile = async (req, res) => {
  try {
    const { emails, permission = "view", message } = req.body;

    // Validate input
    if (!emails || !Array.isArray(emails) || emails.length === 0) {
      return res.status(400).json({
        success: false,
        message: "Emails array is required"
      });
    }

    const codeFile = await CodeFile.findById(req.params.id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if file is approved
    if (codeFile.approvalStatus !== 'approved') {
      return res.status(400).json({
        success: false,
        message: "Only approved files can be shared"
      });
    }

    // Check if user owns the file or is admin
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to share this file"
      });
    }

    const results = {
      successful: [],
      failed: []
    };

    // Process each email
    for (const email of emails) {
      try {
        const normalizedEmail = email.toLowerCase().trim();
        
        // Check if already shared with this email
        const alreadyShared = codeFile.sharing.sharedWith.some(
          share => share.email.toLowerCase() === normalizedEmail
        );

        if (alreadyShared) {
          results.failed.push({
            email: normalizedEmail,
            reason: "Already shared with this email"
          });
          continue;
        }

        // Add to sharedWith array
        codeFile.sharing.sharedWith.push({
          email: normalizedEmail,
          permission: permission,
          sharedBy: req.user.id,
          sharedAt: new Date(),
          message: message || ""
        });

        results.successful.push(normalizedEmail);

        // Send email notification
        try {
          const emailContent = emailTemplates.fileSharedExternal(
            codeFile,
            normalizedEmail,
            req.user,
            permission,
            message
          );
          await sendEmail(normalizedEmail, emailContent.subject, emailContent.html);
        } catch (emailError) {
          console.error(`Email sending failed for ${normalizedEmail}:`, emailError);
          // Continue even if email fails
        }

      } catch (error) {
        results.failed.push({
          email: email,
          reason: error.message
        });
      }
    }

    // Save changes if any successful shares
    if (results.successful.length > 0) {
      codeFile.sharing.isShared = true;
      await codeFile.save();
    }

    res.json({
      success: true,
      message: `File shared with ${results.successful.length} email(s)`,
      data: {
        successful: results.successful,
        failed: results.failed,
        totalShared: codeFile.sharing.sharedWith.length
      }
    });
  } catch (err) {
    console.error('Share file error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Generate public share link
// @route POST /api/code/files/:id/share/link
exports.generateShareLink = async (req, res) => {
  try {
    const { expiresIn = 7, maxUses = null } = req.body; // days

    const codeFile = await CodeFile.findById(req.params.id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if file is approved
    if (codeFile.approvalStatus !== 'approved') {
      return res.status(400).json({
        success: false,
        message: "Only approved files can be shared"
      });
    }

    // Check permissions
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to share this file"
      });
    }

    // Generate unique token
    const crypto = require('crypto');
    const token = crypto.randomBytes(32).toString('hex');
    
    const expirationDate = new Date();
    expirationDate.setDate(expirationDate.getDate() + parseInt(expiresIn));

    // Create share link data
    const shareLink = {
      token: token,
      link: `${process.env.FRONTEND_URL}/shared/${token}`,
      expiresAt: expirationDate,
      maxUses: maxUses,
      createdBy: req.user.id,
      createdAt: new Date(),
      usedCount: 0,
      isActive: true
    };

    // Add to sharing links array
    codeFile.sharing.publicLinks.push(shareLink);
    codeFile.sharing.isShared = true;
    
    await codeFile.save();

    res.json({
      success: true,
      message: "Share link generated successfully",
      data: {
        shareLink: shareLink.link,
        token: shareLink.token,
        expiresAt: shareLink.expiresAt,
        maxUses: shareLink.maxUses,
        qrCode: `${process.env.API_URL}/api/code/files/${req.params.id}/share/qr?token=${token}` // Optional QR code endpoint
      }
    });
  } catch (err) {
    console.error('Generate share link error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Remove collaborator (additional function)
// @route DELETE /api/code/files/:id/collaborators/:userId
// exports.removeCollaborator = async (req, res) => {
//   try {
//     const { userId } = req.params;

//     const codeFile = await CodeFile.findById(req.params.id);
//     if (!codeFile) {
//       return res.status(404).json({
//         success: false,
//         message: "Code file not found"
//       });
//     }

//     // Check if user owns the file or is admin
//     if (codeFile.createdBy.toString() !== req.user.id.toString() && 
//         req.user.role !== 'admin') {
//       return res.status(403).json({
//         success: false,
//         message: "Not authorized to remove collaborators"
//       });
//     }

//     // Find collaborator index
//     const collaboratorIndex = codeFile.collaborators.findIndex(
//       collab => collab.user.toString() === userId
//     );

//     if (collaboratorIndex === -1) {
//       return res.status(404).json({
//         success: false,
//         message: "Collaborator not found"
//       });
//     }

//     // Remove collaborator
//     codeFile.collaborators.splice(collaboratorIndex, 1);
//     await codeFile.save();

//     // Populate for response
//     const updatedFile = await CodeFile.findById(req.params.id)
//       .populate('collaborators.user', 'username email');

//     res.json({
//       success: true,
//       message: "Collaborator removed successfully",
//       data: updatedFile
//     });
//   } catch (err) {
//     console.error('Remove collaborator error:', err);
//     res.status(500).json({ 
//       success: false,
//       message: "Server error: " + err.message 
//     });
//   }
// };

// @desc Revoke share link (additional function)
// @route DELETE /api/code/files/:id/share/link/:token
// exports.revokeShareLink = async (req, res) => {
//   try {
//     const { token } = req.params;

//     const codeFile = await CodeFile.findById(req.params.id);
//     if (!codeFile) {
//       return res.status(404).json({
//         success: false,
//         message: "Code file not found"
//       });
//     }

//     // Check permissions
//     if (codeFile.createdBy.toString() !== req.user.id.toString() && 
//         req.user.role !== 'admin') {
//       return res.status(403).json({
//         success: false,
//         message: "Not authorized to revoke share links"
//       });
//     }

//     // Find share link index
//     const linkIndex = codeFile.sharing.publicLinks.findIndex(
//       link => link.token === token
//     );

//     if (linkIndex === -1) {
//       return res.status(404).json({
//         success: false,
//         message: "Share link not found"
//       });
//     }

//     // Remove share link
//     codeFile.sharing.publicLinks.splice(linkIndex, 1);
    
//     // Update isShared status if no more links or collaborators
//     if (codeFile.sharing.publicLinks.length === 0 && 
//         codeFile.collaborators.length === 0 &&
//         codeFile.sharing.sharedWith.length === 0) {
//       codeFile.sharing.isShared = false;
//     }
    
//     await codeFile.save();

//     res.json({
//       success: true,
//       message: "Share link revoked successfully",
//       data: {
//         remainingLinks: codeFile.sharing.publicLinks.length
//       }
//     });
//   } catch (err) {
//     console.error('Revoke share link error:', err);
//     res.status(500).json({ 
//       success: false,
//       message: "Server error: " + err.message 
//     });
//   }
// };



// controllers/codeController.js (review and approval functions)

// @desc Request review for a code file
// @route POST /api/code/files/:id/request-review
exports.requestReview = async (req, res) => {
  try {
    const { reviewerId, message } = req.body;

    const codeFile = await CodeFile.findById(req.params.id)
      .populate('createdBy', 'username email')
      .populate('currentVersion');
    
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user owns the file or is admin
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to request reviews"
      });
    }

    // Check if file has a current version
    if (!codeFile.currentVersion) {
      return res.status(400).json({
        success: false,
        message: "No version available for review"
      });
    }

    let reviewer;
    if (reviewerId) {
      // Request specific reviewer
      reviewer = await User.findById(reviewerId);
      if (!reviewer) {
        return res.status(404).json({
          success: false,
          message: "Reviewer not found"
        });
      }

      if (reviewer.role !== 'reviewer' && reviewer.role !== 'admin') {
        return res.status(400).json({
          success: false,
          message: "User is not a reviewer"
        });
      }
    } else {
      // Auto-assign reviewer
      const reviewers = await User.find({ 
        role: 'reviewer',
        isActive: true 
      });
      
      if (reviewers.length === 0) {
        return res.status(400).json({
          success: false,
          message: "No reviewers available"
        });
      }
      
      reviewer = reviewers[Math.floor(Math.random() * reviewers.length)];
    }

    // Update code file status
    codeFile.assignedReviewer = reviewer._id;
    codeFile.approvalStatus = 'pending_reviewer';
    codeFile.reviewRequestedAt = new Date();
    codeFile.reviewRequestMessage = message;
    await codeFile.save();

    // Update current version status
    await CodeVersion.findByIdAndUpdate(
      codeFile.currentVersion._id,
      { status: 'pending_reviewer' }
    );

    // Send email notification to reviewer
    if (reviewer.email) {
      try {
        const emailContent = emailTemplates.reviewRequest(
          codeFile,
          reviewer,
          req.user,
          message
        );
        await sendEmail(reviewer.email, emailContent.subject, emailContent.html);
      } catch (emailError) {
        console.error('Email sending failed:', emailError);
      }
    }

    res.json({
      success: true,
      message: `Review requested from ${reviewer.username}`,
      data: {
        codeFile,
        assignedReviewer: reviewer
      }
    });
  } catch (err) {
    console.error('Request review error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Submit version for review
// @route POST /api/code/versions/:id/submit-review
exports.submitForReview = async (req, res) => {
  try {
    const { changeLog, comments } = req.body;

    const codeVersion = await CodeVersion.findById(req.params.id)
      .populate('codeFile')
      .populate('author', 'username email');
    
    if (!codeVersion) {
      return res.status(404).json({
        success: false,
        message: "Code version not found"
      });
    }

    const codeFile = await CodeFile.findById(codeVersion.codeFile._id);
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user owns the version or is admin/collaborator with edit permission
    if (codeVersion.author._id.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin' &&
        !codeFile.collaborators.some(collab => 
          collab.user.toString() === req.user.id.toString() && 
          collab.permission === "suggest_edits"
        )) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to submit this version for review"
      });
    }

    // Update version status
    codeVersion.status = 'pending_reviewer';
    codeVersion.changeLog = changeLog || codeVersion.changeLog;
    codeVersion.submittedForReviewAt = new Date();
    codeVersion.reviewComments = comments;
    await codeVersion.save();

    // Update file status
    codeFile.approvalStatus = 'pending_reviewer';
    codeFile.lastUpdatedBy = req.user.id;
    codeFile.lastUpdatedAt = new Date();
    await codeFile.save();

    // Notify assigned reviewer if exists
    if (codeFile.assignedReviewer) {
      const reviewer = await User.findById(codeFile.assignedReviewer);
      if (reviewer && reviewer.email) {
        try {
          const emailContent = emailTemplates.versionSubmitted(
            codeFile,
            codeVersion,
            reviewer,
            req.user
          );
          await sendEmail(reviewer.email, emailContent.subject, emailContent.html);
        } catch (emailError) {
          console.error('Email sending failed:', emailError);
        }
      }
    }

    res.json({
      success: true,
      message: "Code version submitted for review",
      data: codeVersion
    });
  } catch (err) {
    console.error('Submit for review error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Delete code file and all versions
// @route DELETE /api/code/files/:id
exports.deleteCodeFile = async (req, res) => {
  try {
    const codeFile = await CodeFile.findById(req.params.id);
    
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user owns the file or is admin
    if (codeFile.createdBy.toString() !== req.user.id.toString() && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to delete this file"
      });
    }

    // Get all versions to delete from Cloudinary
    const versions = await CodeVersion.find({ codeFile: req.params.id });

    // Delete all files from Cloudinary
    for (const version of versions) {
      if (version.cloudinaryPublicId) {
        try {
          await cloudinary.uploader.destroy(version.cloudinaryPublicId, {
            resource_type: 'raw'
          });
          console.log('Deleted from Cloudinary:', version.cloudinaryPublicId);
        } catch (cloudinaryError) {
          console.error('Error deleting from Cloudinary:', cloudinaryError);
          // Continue with deletion even if Cloudinary fails
        }
      }
    }

    // Delete versions from database
    await CodeVersion.deleteMany({ codeFile: req.params.id });

    // Delete the code file
    await CodeFile.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: "Code file and all versions deleted successfully"
    });
  } catch (err) {
    console.error('Delete code file error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Reviewer approves code (moves to admin for final approval)
// @route POST /api/code/files/:id/reviewer-approve
exports.reviewerApprove = async (req, res) => {
  try {
    const { comments, reviewType = "technical" } = req.body;

    const codeFile = await CodeFile.findById(req.params.id)
      .populate('currentVersion')
      .populate('createdBy', 'username email')
      .populate('assignedReviewer', 'username email');
    
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user is the assigned reviewer or admin
    if ((!codeFile.assignedReviewer || codeFile.assignedReviewer._id.toString() !== req.user.id.toString()) && 
        req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Not authorized to review this file"
      });
    }

    // Check if there's a current version
    if (!codeFile.currentVersion) {
      return res.status(400).json({
        success: false,
        message: "No current version available for review"
      });
    }

    // Add review to current version
    const currentVersion = await CodeVersion.findById(codeFile.currentVersion._id);
    currentVersion.reviews.push({
      reviewer: req.user.id,
      comments: comments,
      status: "approved",
      reviewType: reviewType,
      reviewedAt: new Date()
    });

    currentVersion.status = 'reviewer_approved';
    await currentVersion.save();

    // Move to admin for final approval
    const adminAssigned = await assignAdmin(codeFile, req.user);

    // Update file status
    codeFile.approvalStatus = 'pending_admin';
    codeFile.reviewerApprovedAt = new Date();
    await codeFile.save();

    // Notify file owner
    if (codeFile.createdBy.email) {
      try {
        const emailContent = emailTemplates.reviewerApproved(
          codeFile,
          codeFile.createdBy,
          req.user,
          comments
        );
        await sendEmail(codeFile.createdBy.email, emailContent.subject, emailContent.html);
      } catch (emailError) {
        console.error('Email sending failed:', emailError);
      }
    }

    res.json({
      success: true,
      message: "Code approved by reviewer, sent to admin for final approval",
      data: {
        codeFile,
        assignedAdmin: adminAssigned,
        review: {
          reviewer: req.user.username,
          comments: comments,
          reviewType: reviewType
        }
      }
    });
  } catch (err) {
    console.error('Reviewer approve error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Admin gives final approval
// @route POST /api/code/files/:id/admin-approve
exports.adminApprove = async (req, res) => {
  try {
    const { comments, makePublic = false } = req.body;

    const codeFile = await CodeFile.findById(req.params.id)
      .populate('currentVersion')
      .populate('createdBy', 'username email')
      .populate('assignedAdmin', 'username email');
    
    if (!codeFile) {
      return res.status(404).json({
        success: false,
        message: "Code file not found"
      });
    }

    // Check if user is admin or assigned admin
    if (req.user.role !== 'admin' && 
        (!codeFile.assignedAdmin || codeFile.assignedAdmin._id.toString() !== req.user.id.toString())) {
      return res.status(403).json({
        success: false,
        message: "Not authorized to give final approval"
      });
    }

    // Check if there's a current version
    if (!codeFile.currentVersion) {
      return res.status(400).json({
        success: false,
        message: "No current version available for approval"
      });
    }

    // Add final approval review
    const currentVersion = await CodeVersion.findById(codeFile.currentVersion._id);
    currentVersion.reviews.push({
      reviewer: req.user.id,
      comments: comments,
      status: "approved",
      reviewType: "final",
      reviewedAt: new Date()
    });

    currentVersion.status = "approved";
    currentVersion.isActive = true;
    await currentVersion.save();

    // Archive previous active versions
    await CodeVersion.updateMany(
      { 
        codeFile: codeFile._id, 
        isActive: true,
        _id: { $ne: currentVersion._id }
      },
      { isActive: false }
    );

    // Update file status
    const updateData = {
      approvalStatus: "approved",
      lastUpdatedBy: req.user.id,
      lastUpdatedAt: new Date(),
      adminApprovedAt: new Date(),
      isPublic: makePublic ? true : codeFile.isPublic
    };

    const updatedFile = await CodeFile.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    )
    .populate('createdBy', 'username email')
    .populate('currentVersion')
    .populate('assignedReviewer', 'username email')
    .populate('assignedAdmin', 'username email');

    // Send approval notification to file owner and reviewer
    const notifications = [];
    if (updatedFile.createdBy.email) {
      try {
        const emailContent = emailTemplates.fileApproved(
          updatedFile,
          updatedFile.createdBy,
          req.user,
          comments
        );
        await sendEmail(updatedFile.createdBy.email, emailContent.subject, emailContent.html);
        notifications.push('owner');
      } catch (emailError) {
        console.error('Email to owner failed:', emailError);
      }
    }

    if (updatedFile.assignedReviewer && updatedFile.assignedReviewer.email) {
      try {
        const emailContent = emailTemplates.reviewCompleted(
          updatedFile,
          updatedFile.assignedReviewer,
          req.user,
          comments
        );
        await sendEmail(updatedFile.assignedReviewer.email, emailContent.subject, emailContent.html);
        notifications.push('reviewer');
      } catch (emailError) {
        console.error('Email to reviewer failed:', emailError);
      }
    }

    res.json({
      success: true,
      message: "Code file approved successfully",
      data: {
        codeFile: updatedFile,
        notifications: notifications
      }
    });
  } catch (err) {
    console.error('Admin approve error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// @desc Review code version (Admin comprehensive review)
// @route POST /api/code/versions/:id/review
exports.reviewCodeVersion = async (req, res) => {
  try {
    const { status, comments, reviewType, feedback, rating } = req.body;

    const codeVersion = await CodeVersion.findById(req.params.id)
      .populate('codeFile')
      .populate('author', 'username email');
    
    if (!codeVersion) {
      return res.status(404).json({
        success: false,
        message: "Code version not found"
      });
    }

    const codeFile = codeVersion.codeFile;

    // Check if user is admin
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: "Admin access required"
      });
    }

    // Add comprehensive review
    const review = {
      reviewer: req.user.id,
      comments: comments,
      status: status,
      reviewType: reviewType || "comprehensive",
      feedback: feedback,
      rating: rating,
      reviewedAt: new Date()
    };

    codeVersion.reviews.push(review);
    codeVersion.status = status;

    let fileUpdateData = {
      lastUpdatedBy: req.user.id,
      lastUpdatedAt: new Date()
    };

    if (status === 'approved') {
      // Make this version active
      codeVersion.isActive = true;
      
      // Archive previous active versions
      await CodeVersion.updateMany(
        { 
          codeFile: codeFile._id, 
          isActive: true,
          _id: { $ne: codeVersion._id }
        },
        { isActive: false }
      );

      fileUpdateData.approvalStatus = 'approved';
      fileUpdateData.currentVersion = codeVersion._id;
      fileUpdateData.adminApprovedAt = new Date();
    } else if (status === 'rejected') {
      fileUpdateData.approvalStatus = 'rejected';
    } else if (status === 'needs_revision') {
      fileUpdateData.approvalStatus = 'needs_revision';
    }

    await codeVersion.save();

    // Update file status
    const updatedFile = await CodeFile.findByIdAndUpdate(
      codeFile._id,
      fileUpdateData,
      { new: true }
    )
    .populate('createdBy', 'username email')
    .populate('currentVersion');

    // Notify author about review result
    if (codeVersion.author.email) {
      try {
        const emailContent = emailTemplates.versionReviewed(
          codeFile,
          codeVersion,
          codeVersion.author,
          req.user,
          review
        );
        await sendEmail(codeVersion.author.email, emailContent.subject, emailContent.html);
      } catch (emailError) {
        console.error('Email sending failed:', emailError);
      }
    }

    res.json({
      success: true,
      message: `Code version ${status} successfully`,
      data: {
        version: codeVersion,
        file: updatedFile,
        review: review
      }
    });
  } catch (err) {
    console.error('Review code version error:', err);
    res.status(500).json({ 
      success: false,
      message: "Server error: " + err.message 
    });
  }
};

// Helper function to assign admin for final approval
const assignAdmin = async (codeFile, reviewedBy) => {
  try {
    const admins = await User.find({ 
      role: 'admin',
      isActive: true 
    });
    
    if (admins.length === 0) {
      console.log('No admins available');
      return null;
    }
    
    // Assign to first available admin
    const admin = admins[0];
    
    codeFile.assignedAdmin = admin._id;
    await codeFile.save();
    
    // Send email notification to admin
    if (admin.email) {
      try {
        const emailContent = emailTemplates.adminApprovalRequest(
          codeFile, 
          admin, 
          reviewedBy
        );
        await sendEmail(admin.email, emailContent.subject, emailContent.html);
      } catch (emailError) {
        console.error('Email sending failed:', emailError);
      }
    }
    
    return admin;
  } catch (error) {
    console.error('Error assigning admin:', error);
    return null;
  }
};
